* Assignment 1
- Print sum of the logarithms of all prime numbers b/w 1 and ~n~
  - Create a list of logarithms of prime numbers b/w 1 and ~n~
  - Sum all numbers in the list
- Find ratio of prime_log_sum and ~n~
* Assignment 2
** Problem 3
- *is_possible (num: Integer)*
  - Returns True if it is possible to make combination of 6, 9 and 20 which is equal to ~number~

    #+BEGIN_SRC python
    for a in range(0, number):
      for b in range(0, number):
        for c in range(0, number):
          if (6*a + 9*b + 20*c) == number: return True

    return False
    #+END_SRC

- *max_impossible (num: Integer)*
  - Returns Last ~number~ which cannot possible to make combination of 6, 9 and 20
  - Start checking from 0 to ~number~
    - if ~number~ is_possible then count with 1
    - if ~number~ is not possible then reset count and not_possible = ~number~
    - if count is equal to 6 return not_possible val

    #+BEGIN_SRC python
    count = 0
    not_possible = 0
      for i in range(num):
          if is_possible(i):
              count += 1
          else:
              count = 0
              not_possible = i

          if count == 6
              return not_possible
    #+END_SRC
* Assignment 3
** Problem 1
- *countSubStringMatch (target: String, key: String)*
  - Takes ~target~ and find how many times ~key~ repeated in ~target~
  - Start finding ~key~ inside ~target~
    - When one time ~key~ found then count with 1
  - Repeat step 1 but start finding from index where previous ~key~ found

  #+BEGIN_SRC python
    count = 0
    index = 0

    while find(target, key, index) != -1:
        count += 1
        index = find(target, key, index) + 1

    return count
  #+END_SRC

- *countSubStringMatchRecursive (target: string, key: string)*
  - Takes ~target~ and find how many times ~key~ repeated in ~target~
  - *Base case*
    - if find(target, key) == -1: return 0
  - *Recursive case*
    - return 1 + countSubStringMatchRecursive(target[find(target, key)+1:], key)
** Problem 2
- *subStringMatchExact (target: string, key: string)*
  - Returns tuple of starting indexes of ~key~ in ~target~
  - Start finding ~key~ index in ~target~
    - When first time ~key~ index found then save index in tuple
  - Repeat step 1 but start finding from index where previous ~key~ found
** Problem 3
- *constrainedMatchPair (firstMatch: tuple, secondMatch: tuple, length: length of firstMatch)*
  - Return tuple of possible match of ~firstMatch~ + ~length~ + 1 is equal to ~secondMatch~
  - Check every item of ~firstMatch~ + ~length~ + 1 is equal to any item in ~secondMatch~
    - If it is True return that item in tuple
** Problem 4
- *subStringMatchExactlyOneSub (target :string, key :string)*
  Returns tuple of starting indexes of ~key~ in ~target~ where ~key~ is having one element substituted in ~target~

  - Take all possible combinations of ~key~ as ~all_key_combinations~
  - Convert each ~pair~ in ~all_key_combinations~ from string to index
    #+BEGIN_SRC python
    pair = (subStringMatchExact(target, pair[0]), subStringMatchExact(target, pair[1]))
    #+END_SRC
  - Find only ~matching_pairs~ from ~all_key_combinations~ using
    ~constrainedMatchPair(pair[0], pair[1], len(pair[0])~
  - Add and return all ~matching_pairs~
* Assignment 4
** Problem 1
- *nestEggFixed (salary :Integer, save :percentage, growthRate :percentage, years :Integer)*
  Returns list of size of your retirement account at the end of each year

  - From first year to ~years~
    - If first year then do ~salary~ * ~save~ * 0.01
      - Save it in ~account_list~
    - otherwise last index of ~account_list~ * (1 + 0.01 * growthRate) + salary * save * 0.01
      - Save it in ~account_list~
  - Return ~account_list~
** Problem 3
- *postRetirement (savings :Integer, growthRates :list, expenses :integer)*
  Returns list of fund size after each year of retirement

- From 0 to length of ~growthRates~
  - If index of ~growthRates~ 0
    - Do (~savings~ * (1 + 0.01 * ~growthRates~[i]) - ~expenses~
      - Save it in ~fund~ list
  - Otherwise last index of ~fund~ * (1 + 0.01 * ~growthRates~[i]) - ~expenses~
    - Save it in ~fund~ list
- Return ~fund~
