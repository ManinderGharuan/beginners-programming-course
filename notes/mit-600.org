* Lecture 1

  - *Computation*
    - Declarative knowledge
      - Tells you *what* something is, not *how* to do it
      - Closest it gets is allow us to *test* it

      e.g
      #+BEGIN_EXAMPLE
      \sqrt{x} is a number ~y~ s.t y^2 = x and y != 0
      #+END_EXAMPLE

    - Imperative knowledge
      - Tells us *how* to do something
      - A sequence of instructions to do something

      e.g
      #+BEGIN_EXAMPLE
      - Start with a guess ~g~
      - If g^2 = x, stop, return g
      - else g = (g + x/g) / 2
      - repeat
      #+END_EXAMPLE

    - *Computation* is about capturing the process of coming up with imperative process to do something
    - A computation is based on a fixed set of primitive which are used to create complex computation

  - *Programming language*
    - There is no best programming-language, but some languages are better at doing certain things than other languages
    - Language used in this course is python, but the course is not about Python. It is about how to program, Python is only a programming language choice and once we know to code in one language (Python in our case), we can learn a new language easily
    - Different dimensions of a language
      - High vs Low level

        Low level: Very close to hardware. Primitives are moving data from one location in memory to other High level: Much richer set of primitives

      - General vs targeted

        General: For general purpose programming. Can be used to do a lot of things e.g Python Targeted: Designed for a specific purpose, e.g Maths(Mat-lab)

      - Interpreted vs Compiled

        Interpreted: Interpreted work directly on source-code at run time Compiled: Compiler complies code to intermediate form (Object code) which actually runs finally

    - Python is
      - High level
      - General purpose
      - Interpreted
    - *Syntax of a language*

      What are the legal expressions in this language

    - *Static Semantics of a language

      says which programs are meaningful i.e which expressions make sense

    - *Semantics of a language

      says what a program means, i.e what happen when the program runs
* Lecture 2
  - /Operands/ and /operators/ make the expressions to do operations

  - Expressions can be typed directly in /interpreter/
    - Interpreter evaluate expressions and print
    - *Operator Overloading*
      - Same operator behaves differently with different types, e.g + (plus) operator will, perform arithmetic addition on two numbers, concatenate two strings
      - Multiplication between two integer, will return an interger value
        - But multiplication between integer and string, will return new string
      - Adding two string together, will combine that strings

     - Type checking in python
        - Cannot add interger value with string

          e.g
          #+BEGIN_SRC python
          3*4
          # 12

          3*'ab'
          # 'ababab'

          'a'+'bcd'
          #Joined two strings 'abcd'

          3+'ab'
          #Error because interger cannot join with string

          str(3)+'ab'
          # '3ab', str() is a type conversion
          #+END_SRC
        - /Type conversion/: Convert integer into string

  - *Operator precedence*
    - Operators have their priority order in which they operate
    - Exponentiation are done before multiplication or division are done before addition and subtraction
    - Expressions in parenthesis are done before multiplication (parenthesis are executed first)

      e.g
      #+BEGIN_SRC python
      3+4*5
      #Return 23, because multiplication done before addition

      (3+4)*5
      #Return 35, because addition under parentheses done before multiplication
      #+END_SRC

  - *Variables*
    - Variables are created using an assignment statement and they have there own values

      e.g
      #+BEGIN_SRC python
      x = 3
      #It assign integer value to variable x
      #+END_SRC

    - Assigning a variable gives it a data-type which is dynamically derived from its value

        e.g
        #+BEGIN_SRC python
        x = 3
        #x has integer value and type

        x = 'abc'
        #Now type of x is changed from integer to string
        #+END_SRC

  - *Statement*
    - Legal commands that python interpret: /print/, /assignment/
    - *Print* put it back out in the screen
    - *Assignmen* binding a name to a value

  - *Style*
    - Styles are very important in every programing language
    - It help to understand code easily
    - *Comment*: # (/HASH/) is using for comment section in python
      - Comments can help to find what is going on inside code
    - *Variable names*: Chosse variable names that make sense
      - It tells what is trying to capture inside variable

  - *Branching programs*: can change the order of instructions based on a test usually value of a variable
    - *if statement*: if test is true, then do set of things and if test is false then skip that step
    - *else statement*: if test is false then do this part

      Syntax
      #+BEGIN_EXAMPLE
      if <some text>:
         Block of instruction
      else:
         Block of instruction
      #+END_EXAMPLE

      e.g
      #+BEGIN_SRC python
      x = 15
      if (x/2)*2 == x:
         print 'Even'
      else: print 'Odd'
      #x is a variable which is having integer value 15
      #if condition is true do next thing after the colon
      #The sign '==' is comparing both sides
      #if condition false else will do next thing after the colon
      #+END_SRC

  - *Boolean Combination*: /and/, /or/, /not/
    - There are two types of Boolean is *True*, *False*
    - *AND*: if both arguments are true it's true
    - *OR*: if one argument true it's true
    - *NOT*: if argument is not true it's true

  - *Iteration or loops*: reuse same code over and over again

* Lecture 3
-We have looked at three different kinds of things: /Data/, /Operations/ and /Statements/
  - *Data*:
    - We have done /numbers/, /strings/ and /Boolean/

  - *Operations*:
    - /Additions/ and /multiplications/
    - /and/, /or/

  - *Statements*:
    - /Assignment/
    - /input/output/ (e.g raw input for input and print for output)
    - /Branches/
    - /loop mechanisms/ (e.g while)

** Iterative programs
- Iterative is used to describe a situation in which a sequence of instructions can be executed multiple times
- Following are the steps
  - Choose a variable that count
  - Initialize outside the loop
  - Setup end test (variable)
  - Construct block
    - Change variable
  - What to do when done

- *Flow chart*
  - Flow chart is how to structure the code

#+BEGIN_SRC python
x = 16                #Initialize variable
ans = 0               #Variale that count
while ans*ans < x:    #Setup end test or condition
  ans = ans + 1       #Change variable
print ans             #Display 'ans' when done
#+END_SRC

Every looping construct should always be able to terminate and it should give a reasonable answer

** Defensive programming
 - Make sure there is no syntax error or any infinite loop
 - Always check user's input for mistakes

e.g
#+BEGIN_SRC python
x = 16
ans = 0
if x >= 0;
  while ans*ans < x:
    ans = ans + 1
  if ans*ans != x:
    print x, ' is not a perfect number'
  else: print ans
else: print x, ' is a negative number'
#+END_SRC

** Exhaustive enumeration
- Try all reasonable values until you find the solution

  e.g
  #+BEGIN_SRC python
  x = 10
  i = 1
  while i<x:
    if x%i == 0:
      print 'divisor ', i
    i = i + 1
  #+END_SRC

** For loop
- for loop updates the variable automatically
  - It allows to be sure that /For loop/ is going to terminate

  syntax
  #+BEGIN_EXAMPLE
  for <var> in <some collection>:
  block of code
  #+END_EXAMPLE
  Using that variable as placeholder have it walk through collection that starting at the first thing, execute that code, then next thing, execute that code, and so on

 e.g
#+BEGIN_SRC python
x = 10
for i in range(1, x):   #It gives all integer from 1 up to x
  if x%i == 0:
    print 'divide ', i
#+END_SRC

** Range
- Range is built-in python function
- It gives all the integers from lower to upper

  e.g
  #+BEGIN_SRC python
  range(1, 10)  #It gives integer from 1 to 10
  #1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  #+END_SRC

** Tuple
- This is an ordered sequence of elements
- It is immutable
- Representation of tuple is parenthesis (i.e round bracket), followed by a sequence of element, separated by commas and followed by a close parenthesis bracket
  e.g t = (1, 2, 3, 4)
- *Selection* using to select the positions or index, e.g t[1]
- *Slicing* using to pick up pieces, e.g t[1:3]

e.g
#+BEGIN_SRC python
test = (1, 2, 3, 4)
test[0]
# 1

test[3]
# 4

test[-1]
# 4

test[1:3]
#(2, 3)
#+END_SRC

** String
- It is an ordered sequence of characters
- String also support selection and slicing
* Lecture 4
- *Decomposition*: is a way of putting structure onto the code (way of breaking the code up into modules
- *Abstraction*: means to give names to things, so that name captures the core of what a function or whole program does

- *Functions*: Function is a block of organized, reusable code that is used to perform a single, related action
  - It break up into modules
  - Suppress detail
  - It creates new primitives

  Syntax:
    - *def* is a keyword (Definition or define)
      - It followed by name (This name is refer when we want to use this function)
      - Function name is having open and close parenthesis with variable name inside it, i.e name(x)
      - *Name(x)* defines formal parameters of function
    - *Specification* is /what/ does this function do
    - *return* (keyword)
    - Every possible path through code ends in a *return*

    e.g
    #+BEGIN_SRC python
      def sqrt(x):
        """Return the square root of x, if x is a perfect square.
             Prints an error message and returns None otherwise"""   #it is a specification
        ans = 0
        if x >= 0:
          while ans*ans < x: ans = ans + 1
          if ans*ans != x:
              print x, 'is not a perfect square'
              return None
          else: return ans
        else:
          print x, 'is a negative number'
          return None

       #sqrt(16)
       #It will display 4
    #+END_SRC

  - To call a function by passing in values for the parameters, i.e sqrt(16)
    - It binds x to 16 (this binding is local, it only holds within the confines of the code of this procedure)
    - Inside the function block every bindings are local
    - *Local bindings*: do not affect global bindings

- *Recursion*: is the process of defining a problem (or the solution to a problem) into nice sized chunks
  - Base case: It is the simplest possible solution to the problem
  - Inductive step (or recursive step) break the problem into a simpler version of the same problem and some other steps

  e.g
  #+BEGIN_SRC python
    def isPalindrome(s):
        """Returns True if s is a palindrome and False otherwise."""
        if len(s) <= 1: return True
        else: return s[0] == s[-1] and isPalindrome(s[1:-1])

    def isPalindrome1(s, indent):
        """Returns True if s is a palindrome and False otherwise"""
        print indent, 'isPalindrome called with', s
        if len(s) <= 1 :
            print index, 'About to return True from base case'
            return True
        else:
            ans = s[0] == s[-1] and isPalindrome1(s[1:-1], indent + indent)
            return ans
  #+END_SRC
